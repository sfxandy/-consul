Got it — here are the same tests rewritten as plain “Given / When / Then” acceptance criteria.

Sidecars register and are ready

Given a healthy Consul datacenter with Connect enabled, Service A and Service B registered with sidecars, and both services passing health

When the Envoy sidecars for Service A and Service B start

Then both proxies appear as sidecar-proxy instances in Consul, the Envoy readiness endpoints return 200, and both services remain passing

mTLS is enforced

Given an allow intention from Service A → Service B

When Service A calls Service B through its local upstream

Then the call succeeds (HTTP 200), the connection is TLS using a Consul-issued peer cert, and the cert identity matches Service B

Intention allows traffic

Given an allow intention from Service A → Service B

When Service A calls Service B

Then the response status is 200

Intention denies traffic

Given a deny (or no) intention from Service A → Service B

When Service A calls Service B

Then the call is blocked by the proxy (e.g., HTTP 403)

Health checks gate routing

Given Service B has two instances where one is failing health and an allow intention exists

When Service A sends multiple requests to Service B

Then no requests are sent to the failing instance and all responses come from healthy instance(s)

Retry and timeout policy honored

Given a policy of 2 retries and 500 ms per-try timeout for A → B, and the first upstream attempt returns 503

When Service A makes a request

Then the proxy retries up to 2 times, succeeds if a subsequent attempt is 200, and total latency respects the overall timeout

Path-based L7 routing

Given a router that sends /v2/* to Service B v2 and other paths to Service B v1, with allow intentions in place

When Service A requests /v2/status and /v1/status

Then /v2/status is served by v2 and /v1/status by v1

Traffic splitting (progressive delivery)

Given a splitter on Service B sending 80% to v1 and 20% to v2 with allow intentions

When Service A sends 1000 requests to Service B

Then ~80% of responses come from v1 and ~20% from v2 within tolerance

Certificate rotation continuity

Given active mTLS between Service A and Service B

When Consul rotates leaf certificates

Then in-flight connections remain stable and new connections succeed with the new certs

Failure isolation when app down

Given the Service B app process is stopped while its sidecar runs, and an allow intention exists

When Service A calls Service B

Then Envoy returns a fast upstream-unavailable error (e.g., 503), and after Service B recovers and health passes, subsequent calls return 200 without proxy restarts

Mesh observability

Given Envoy access logs and /stats are enabled and intentions allow traffic

When Service A makes requests to Service B

Then access logs record source service, upstream cluster, and response codes, and Envoy stats counters increase appropriately

Consul DNS outside the mesh (optional)

Given Consul DNS is available

When resolving service-b.service.consul

Then A/AAAA records are returned only for healthy instances

Cross-namespace/partition access control (outline)

Given Service A in namespace/partition X and Service B in namespace/partition Y with <allow|deny> intention

When Service A calls Service B

Then the request <succeeds|is denied> according to the intention

Version-aware routing by header (outline)

Given a router mapping header X-Api-Version: <ver> to backend service-b-<ver> and allow intentions

When Service A calls Service B with header X-Api-Version: v1 or v2

Then the response is served by service-b-v1 or service-b-v2 respectively
